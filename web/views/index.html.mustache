<html>
<head>
	{{> header.html}}
	<script type="text/javascript" src="js/xhr.js"></script>
	<script type="text/javascript">
		var text;
		var needle;
		var canvas;
		var gl;

		function init() {
			text = document.getElementById("text");
			needle = document.getElementById("needle");
			
			initGL();

			refresh();
		}

		function initGL() {
			canvas = document.getElementById('vessel');
			gl = canvas.getContext('webgl');

			if (!gl) {
				return;
			}

			var vertexShaderSource = document.getElementById("2d-vertex-shader").text;
			var fragmentShaderSource = document.getElementById("2d-fragment-shader").text;
			 
			var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
			var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

			var program = createProgram(gl, vertexShader, fragmentShader);

			var positionAttributeLocation = gl.getAttribLocation(program, "a_position");

			var positionBuffer = gl.createBuffer();

			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

			// three 2d points
			var positions = [
				0, 0,
				0, 0.5,
				0.7, 0,
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

			resize(canvas);
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			gl.clearColor(0, 0, 0, 0);
			gl.clear(gl.COLOR_BUFFER_BIT);

			gl.useProgram(program);

			gl.enableVertexAttribArray(positionAttributeLocation);

			// Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
			var size = 2;          // 2 components per iteration
			var type = gl.FLOAT;   // the data is 32bit floats
			var normalize = false; // don't normalize the data
			var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
			var offset = 0;        // start at the beginning of the buffer
			gl.vertexAttribPointer(
			    positionAttributeLocation, size, type, normalize, stride, offset)

			// draw
			var primitiveType = gl.TRIANGLES;
			var offset = 0;
			var count = 3;

			gl.drawArrays(primitiveType, offset, count);
		}

		function resize(canvas) {
			// Lookup the size the browser is displaying the canvas.
			var displayWidth  = canvas.clientWidth;
			var displayHeight = canvas.clientHeight;
			
			// Check if the canvas is not the same size.
			if (canvas.width != displayWidth || canvas.height != displayHeight) {
				// Make the canvas the same size
				canvas.width  = displayWidth;
				canvas.height = displayHeight;
			}
		}

		function createShader(gl, type, source) {
			var shader = gl.createShader(type);

			gl.shaderSource(shader, source);
			gl.compileShader(shader);

			var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

			if (success) {
				return shader;
			}
			
			console.log(gl.getShaderInfoLog(shader));

			gl.deleteShader(shader);
		}

		function createProgram(gl, vertexShader, fragmentShader) {
			var program = gl.createProgram();

			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);

			var success = gl.getProgramParameter(program, gl.LINK_STATUS);

			if (success) {
				return program;
			}
			
			console.log(gl.getProgramInfoLog(program));

			gl.deleteProgram(program);
		}

		function refresh() {
			xhr.get('/nav', update);
		}

		function update(err, data) {
			text.innerText = JSON.stringify(data, null, 2);

			if ("compass" in data) {
				let compass = data.compass;

				if ("angle" in compass) {
					let angle = compass.angle

					angle -= 90.0

					if (angle < 0.0) {
						angle += 360.0
					}

					needle.setAttribute("transform", "rotate(" + angle + ")");
				}
			}

			if ("status" in data === false || data.status != 500) {
				setTimeout(refresh, 1000);
			}
		}
	</script>
	<script id="2d-vertex-shader" type="text/vertex-shader">
		attribute vec4 a_position;
		
		void main() {
			gl_Position = a_position;
		}
	</script>
	<script id="2d-fragment-shader" type="text/fragment-shader">
		precision mediump float;
		 
		void main() {
			gl_FragColor = vec4(1, 0, 0.5, 1);
		}
	</script>
</head>
<body onload="init()">
	<div style="position: relative;">
		<img class="mjpeg" src="http://192.168.0.1:8080/stream/video.mjpeg" width="85%" height="85%"/>
		<div style="position: absolute; top: 0; left: 0">
			<pre id="text"></pre>
			<svg xmlns="http://www.w3.org/2000/svg" id="compass" width="60" height="60" viewbox="0 0 60 60">
				<g transform="translate(30,30)">
					<circle r="30" fill="green" />
					<g id="needle" transform="rotate(0)">
						<line x2="30" stroke="red" stroke-width="2" />
					</g>
				</g>
			</svg>
			<canvas id="vessel" width="200" height="200"></canvas>
		</div>
	</div>
</body>
</html>
